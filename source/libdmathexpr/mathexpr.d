module libdmathexpr.mathexpr;
/**
 * LibDMathExpr contains functions and classes for parsing and writing math 
 * equations.
 *
 * Copyright:   (c) 2009 William K. Moore, III (nyphbl8d (at) gmail (dot) com, opticron on freenode)
 * Authors:     William K. Moore, III
 * License:     Boost Software License - Version 1.0 - August 17th, 2003

 Permission is hereby granted, free of charge, to any person or organization
 obtaining a copy of the software and accompanying documentation covered by
 this license (the "Software") to use, reproduce, display, distribute,
 execute, and transmit the Software, and to prepare derivative works of the
 Software, and to permit third-parties to whom the Software is furnished to
 do so, all subject to the following:

 The copyright notices in the Software and this entire statement, including
 the above license grant, this restriction and the following disclaimer,
 must be included in all copies of the Software, in whole or in part, and
 all derivative works of the Software, unless such copies or derivative
 works are solely in the form of machine-executable object code generated by
 a source language processor.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.

 */

version(Tango) {
	import tango.text.Util:stripl=triml,strip=trim,stripr=trimr,find=locatePattern,split,replace=substitute,join;
	import tango.text.convert.Integer:tostring=toString,atoi=toInt;
	import tango.text.convert.Float:tostring=toString,atof=toFloat;
	import tango.text.Ascii:icmp=icompare,cmp=compare,tolower=toLower;
	import tango.io.Stdout:logln=Stdout;
	import tango.text.Regex;
	import tango.math.Math;
	import tango.math.GammaFunction:tgamma=gamma;
	alias char[] string;
	string regrep(string input,string pattern,string delegate(string) translator) {
		string tmpdel(RegExpT!(char) m) {
			return translator(m.match(0));
		}
		auto rgxp = Regex(pattern,"g");
		return rgxp.replaceAll(input,&tmpdel);
	}
} else {
	version(D_Version2) {
		import std.conv:to;
		import std.string:strip,stripr=stripRight,stripl=stripLeft,split,replace,find=indexOf,cmp,icmp,atoi,join,tolower=toLower;
		real atof(string data) {
			return to!(real)(data);
		}
		string tostring(real data) {
			return to!(string)(data);
		}
		import std.regex;
		string regrep(string input, string pattern, string delegate(string) translator) {
			string tmpdel(Captures!(string) m) {
				return translator(m.hit);
			}
			return std.regex.replace!(tmpdel)(input, regex(pattern, "g"));
		}
		import std.mathspecial:tgamma=gamma;
	} else {
		import std.string:tostring=toString,strip,stripr,stripl,split,replace,find,cmp,icmp,atoi,atof,tolower,join;
		import std.regexp:sub,RegExp;
		string regrep(string input,string pattern,string delegate(string) translator) {
			string tmpdel(RegExp m) {
				return translator(m.match(0));
			}
			return std.regexp.sub(input,pattern,&tmpdel,"g");
		}
	}
	import std.stdio;
	import std.math;
	void logln(string str) {writef("%s",str);}
}

/// An exception thrown on math parsing errors.
class MathParseError : Exception {
	// Throws an exception with an error message.
	this(string msg) {
		super(msg);
	}
}

interface IMathObject {
	void parse(ref string input);
	string toString();
	real evaluate(real[string]vars);
	IMathObject simplify(real[string]vars);
}

const string tryEval = 
"		try {
			return new MONumber(evaluate(vars));
		} catch {}";

enum MOOpType {
	Addition,
	Multiplication,
	Exponentiation,
	Negation,
	Modulus,
	Inversion
}
string toString(MOOpType op) {
	switch(op) {
	case MOOpType.Addition: return " + ";
	case MOOpType.Multiplication: return " * ";
	case MOOpType.Negation: return " -";
	case MOOpType.Inversion: return "1/";
	case MOOpType.Modulus: return "%";
	default: throw new MathParseError("Unknown operation!");
	}
}

int getPrevElem(IMathObject[]tokens,int i) {
	i--;
	for (;i>=0;i--) {
		if (tokens[i]) return i;
	}
	return -1;
}

int getNextElem(IMathObject[]tokens,int i) {
	i++;
	for (;i<tokens.length;i++) {
		if (tokens[i]) return i;
	}
	return -1;
}

IMathObject parseMathExpr(string input) {
	// split the string into IMathObject tokens
	IMathObject[]tokens = splitMathExpr(input);
	// go through the process of turning this thing into a tree instead of a flat list
	// parens are already expanded
	// exponentials
	for (int i = 0;i < tokens.length;i++) {
		auto caster = cast(MOOperation)tokens[i];
		if (caster && caster.op == MOOpType.Exponentiation) {
			// must not be at the beginning or end of the string
			if (i == 0 || i == tokens.length-1) {
				throw new MathParseError("Exponentiation must have 2 operands");
			}
			// subitems must be parens or numbers
			int prev = getPrevElem(tokens,i),next = getNextElem(tokens,i);
			if (prev == -1 || (!cast(MOParens)tokens[prev] && !cast(MONumber)tokens[prev] && !cast(MOIdentifier)tokens[prev])) {
				// the previous entity can be an operation, but only if it's also an exponential
				throw new MathParseError("Exponentiation operators must be parens or numbers");
			}
			if (next == -1 || (!cast(MOParens)tokens[next] && !cast(MONumber)tokens[next] && !cast(MOIdentifier)tokens[next] && !cast(MONegation)tokens[next])) {
				throw new MathParseError("Exponentiation operators must be parens or numbers");
			}
			// resolve negation here for more fun
			if (cast(MONegation)tokens[next]) {
				// find next non-negation node
				int noneg = next+1;
				while (noneg < tokens.length) {
					if (tokens[noneg] && !cast(MONegation)tokens[noneg]) {
						break;
					}
					noneg++;
				}
				if (!tokens[noneg] || cast(MONegation)tokens[noneg]) {
					throw new MathParseError("Negation slide as exponent blew up");
				}
				// fold negation slide into exponential
				int lastgood = noneg;
				noneg--;
				while (noneg >= next) {
					if (tokens[noneg]) {
						(cast(MONegation)tokens[noneg]).rhs = tokens[lastgood];
						tokens[lastgood] = null;
						lastgood = noneg;
					}
					noneg--;
				}
			}
			// pull a quick one and convert to the function call
			tokens[i] = new MOIdentifier("pow",[cast(IMathObject)tokens[prev],tokens[next]]);
			// move the adjacent objects into the tree
			tokens[prev] = null;
			tokens[next] = null;
		}
	}
	// evaluate inversion
	for (int i = cast(int)tokens.length-1;i >= 0;i--) {
		auto caster = cast(MOInversion)tokens[i];
		if (caster) {
			// must not be at the end of the string
			if (i == tokens.length-1) {
				throw new MathParseError("Inversion must have an operand");
			}
			// subitems must be parens or numbers
			int next = getNextElem(tokens,i);
			if (next == -1) {
				throw new MathParseError("Inversion must have an operand");
			}
			// if this param is an operation, both fields need to be filled
			auto ntmp = cast(MOOperation)tokens[next];
			if (ntmp) {
				throw new MathParseError("Double operators? really? (inversion)");
			}
			// move the adjacent objects into the tree
			caster.rhs = tokens[next];
			tokens[next] = null;
		}
	}
	// evaluate negation back to front to accomodate slides
	for (int i = cast(int)tokens.length-1;i >= 0;i--) {
		auto caster = cast(MONegation)tokens[i];
		if (caster) {
			// must not be at the end of the string
			if (i == tokens.length-1) {
				throw new MathParseError("Negation must have an operand");
			}
			// subitems must be parens or numbers
			int next = getNextElem(tokens,i);
			if (next == -1) {
				throw new MathParseError("Negation must have an operand");
			}
			// if this param is an operation, both fields need to be filled
			auto ntmp = cast(MOOperation)tokens[next];
			if (ntmp && !ntmp.validate()) {
				throw new MathParseError("Double operators? really? (negation)");
			}
			// move the adjacent objects into the tree
			caster.rhs = tokens[next];
			tokens[next] = null;
		}
	}
	// helper function
	void parseHelper(bool delegate(MOOpType) valid) {
		for (int i = 0;i < tokens.length;i++) {
			auto caster = cast(MOOperation)tokens[i];
			if (caster && valid(caster.op)) {
				// must not be at the beginning or end of the string
				if (i == 0 || i == tokens.length-1) {
					throw new MathParseError("Operators must have 2 operands");
				}
				// subitems must be parens or numbers
				int prev = getPrevElem(tokens,i),next = getNextElem(tokens,i);
				if (prev == -1) {
					throw new MathParseError("Operators must have 2 operands");
				}
				// if this param is an operation, both fields need to be filled
				auto ptmp = cast(MOOperation)tokens[prev];
				if (ptmp && !ptmp.validate()) {
					throw new MathParseError("Double operators? really?");
				}
				if (next == -1) {
					throw new MathParseError("Operators must have 2 operands");
				}
				// if this param is an operation, both fields need to be filled
				auto ntmp = cast(MOOperation)tokens[next];
				if (ntmp && !ntmp.validate()) {
					throw new MathParseError("Double operators? really?");
				}
				// move the adjacent objects into the tree
				caster.operands ~= tokens[prev];
				tokens[prev] = null;
				caster.operands ~= tokens[next];
				tokens[next] = null;
			}
		}
	}
	// multiplication
	parseHelper((MOOpType o){return o == MOOpType.Multiplication || o == MOOpType.Modulus;});
	// addition
	parseHelper((MOOpType o){return o == MOOpType.Addition;});
	// now that we have the tree fully formed simplify the tree
	// flatten tree
	foreach (token;tokens) if (token) {
		auto tmp = cast(MOOperation)token;
		if (tmp) {
			tmp.flatten();
		}
	}
	// verify that we're left with a single item in the list
	long count = 0;
	uint first;
	foreach(uint i,c;tokens) if (c) {count++;first=i;}
	if (count != 1) {
		throw new MathParseError("FUUUUUUUUUUU count="~tostring(count));
	}
	return tokens[first];
}

enum {
	NUMBER,
	OPERATOR,
	PAREN,
	SPACE,
	IDENTIFIER,
}

int getCharType(char i) {
	if (i >= '0' && i <= '9') return NUMBER;
	if (i >= 'a' && i <= 'z' || i >= 'A' && i <= 'Z') return IDENTIFIER;
	switch (i) {
	case '+':
	case '-':
	case '*':
	case '/':
	case '^':
	case '%':
		return OPERATOR;
	case ' ':
	case '\n':
	case '\r':
		return SPACE;
	case '(':
		return PAREN;
	case '.':
		return NUMBER;
	default:
		throw new MathParseError("Invalid character: "~i);
	}
}

IMathObject[]splitMathExpr(string input) {
	// respect parens and pass them back into parseMathExpr for further parsing
	IMathObject[]tmp;
	void doAutoMul() {
		if (tmp.length && (cast(MONumber)tmp[$-1] || cast(MOParens)tmp[$-1] || cast(MOIdentifier)tmp[$-1])) {
			tmp ~= new MOOperation("*");
		}
	}
	int slice = 0;
	while (input.length) {
		switch (getCharType(input[0])) {
		case NUMBER:
			// if the previous item was a number, barf, can't have adjacent numerics because it doesn't make sense
			if (tmp.length && cast(MONumber)tmp[$-1]) throw new MathParseError("Numerics can not be adjacent. Secondary starting at: "~input);
			// add mul op if necessary
			doAutoMul();
			tmp ~= new MONumber(input);
			break;
		case OPERATOR:
			// take care of division via mul+inversion
			if (input[0] == '/') {
				tmp ~= new MOOperation("*");
				tmp ~= new MOInversion(input);
				input = input[1..$];
				continue;
			} else if (input[0] == '-') {
				if (tmp.length && !cast(MOOperation)tmp[$-1] && !cast(MONegation)tmp[$-1]) {
					// tack on a +
					tmp ~= new MOOperation("+");
				}
				tmp ~= new MONegation(input);
				input = input[1..$];
				continue;
			}
			tmp ~= new MOOperation(input[0..1]);
			input = input[1..$];
			break;
		case PAREN:
			// add mul op if necessary
			doAutoMul();
			tmp ~= new MOParens(input);
			break;
		case SPACE:
			input = input[1..$];
			break;
		default:// assume identifier
		case IDENTIFIER:
			// add mul op if necessary
			doAutoMul();
			tmp ~= new MOIdentifier(input);
			break;
		}
	}
	return tmp;
}

class MONegation:IMathObject {
	IMathObject rhs;
	this (ref string c) {
		parse(c);
	}
	this(){}
	/// Return the string that was used to generate this node.
	override string toString() {
		return "-"~rhs.toString();
	}
	/// Return the numeric data represented by this node.
	real evaluate(real[string]vars) {
		return -rhs.evaluate(vars);
	}
	/// This function parses a set of nodes out of an equation string.
	void parse(ref string source) {
		// this does nothing on purpose, it will not be used by default
	}
	/// Return the simplification of this node (where possible).
	IMathObject simplify(real[string]vars) {
		mixin(tryEval);
		// pass the simplification up the tree first
		rhs = rhs.simplify(vars);
		// see if we can wrap two negations into one
		auto caster = cast(MONegation)rhs;
		if (caster) return caster.rhs;
		return this;
	}
}

class MOInversion:IMathObject {
	IMathObject rhs;
	this (ref string c) {
		parse(c);
	}
	/// Return the string that was used to generate this node.
	override string toString() {
		return "1/"~rhs.toString();
	}
	/// Return the numeric data represented by this node.
	real evaluate(real[string]vars) {
		return 1/rhs.evaluate(vars);
	}
	/// This function parses a set of nodes out of an equation string.
	void parse(ref string source) {
		// this does nothing on purpose, it will not be used by default
	}
	/// Return the simplification of this node (where possible).
	IMathObject simplify(real[string]vars) {
		mixin(tryEval);
		// it only makes sense to pass the simplification up the tree here since negation is so simple
		rhs = rhs.simplify(vars);
		return this;
	}
}


// holds the builtin functions and the number of args
int[string]builtins;
static this () {
	builtins = ["cos"[]:1, "tan":1, "sin":1, "cosh":1, "tanh":1, "sinh":1, "acos":1, "atan":1, "asin":1, "acosh":1, "atanh":1, "asinh":1, "pow":2, "log":1, "ln":1, "int":1, "frac":1, "abs":1, "sqrt":1, "exp":1, "gamma":1, "mod":2];
}
class MOIdentifier:IMathObject {
	string identifier;
	IMathObject[]args;
	this (ref string c) {
		parse(c);
	}
	this (string id,IMathObject[]inargs) {
		identifier = id;
		args = inargs;
	}
	/// Return the string that was used to generate this node.
	override string toString() {
		auto ret = identifier;
		if (args.length) {
			ret ~= "(";
			foreach(arg;args) ret ~= arg.toString();
			ret ~= ")";
		}
		return ret;
	}
	bool isBuiltin(string fun) {
		return (fun in builtins) != null;
	}
	/// Return the numeric data represented by this node.
	real evaluate(real[string]vars) {
		// ensure we have the right number of args if it's a function
		if (isBuiltin(identifier) && args.length != builtins[identifier]) {
			throw new MathParseError("Wrong number of arguments for "~identifier);
		}
		switch (identifier) {
		case "cos":
			return cos(args[0].evaluate(vars));
		case "tan":
			return tan(args[0].evaluate(vars));
		case "sin":
			return sin(args[0].evaluate(vars));
		case "cosh":
			return cosh(args[0].evaluate(vars));
		case "tanh":
			return tanh(args[0].evaluate(vars));
		case "sinh":
			return sinh(args[0].evaluate(vars));
		case "acos":
			return acos(args[0].evaluate(vars));
		case "atan":
			return atan(args[0].evaluate(vars));
		case "asin":
			return asin(args[0].evaluate(vars));
		case "acosh":
			return acosh(args[0].evaluate(vars));
		case "atanh":
			return atanh(args[0].evaluate(vars));
		case "asinh":
			return asinh(args[0].evaluate(vars));
		case "pow":
			return pow(args[0].evaluate(vars),args[1].evaluate(vars));
		case "log":
			return log10(args[0].evaluate(vars));
		case "ln":
			return log(args[0].evaluate(vars));
		case "abs":
			return abs(args[0].evaluate(vars));
		case "sqrt":
			return sqrt(args[0].evaluate(vars));
		case "exp":
			return exp(args[0].evaluate(vars));
		case "gamma":
			return tgamma(args[0].evaluate(vars));
		case "int":
			auto tmp = args[0].evaluate(vars);
			return tmp-(tmp%1);
		case "frac":
			return args[0].evaluate(vars)%1;
		case "mod":
			return args[0].evaluate(vars)%args[1].evaluate(vars);
		case "e": return E;
		case "pi": return PI;
		default:
			// check variables
			if (identifier in vars) {
				auto ret = vars[identifier];
				if (args.length == 1) {
					ret *= args[0].evaluate(vars);
				}
				return ret;
			}
			throw new MathParseError("Unknown identifier: "~identifier);
		}
	}
	/// This function parses a set of nodes out of an equation string.
	void parse(ref string source) {
		string getIden(ref string src) {
			foreach(i,c;src) if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z')) {
				auto tmp = src[0..i];
				src = src[i..$];
				return tmp;
			}
			auto tmp = src;
			src = "";
			return tmp;
		}
		// if the identifier is our variable, don't look for parens or args
		identifier = tolower(getIden(source));
		// strip out whitespace
		source = stripl(source);
		// parse out parameters if necessary
		if (!source.length || source[0] != '(') {
			if (isBuiltin(identifier)) {
				throw new MathParseError("Couldn't parse args for "~identifier);
			}
			// this is a variable
			return;
		}
		int count = 0;
		uint laststart = 1;
		foreach (uint i,c;source) {
			switch (c) {
			case '(': count++; break;
			case ')': count--; break;
			default: break;
			case ',':
				// parse a new arg if we're at the first level
				if (count == 1) {
					args ~= parseMathExpr(source[laststart..i]);
					laststart = i+1;
				}
				break;
			}
			if (!count) {
				args ~= parseMathExpr(source[laststart..i]);
				source = source[i+1..$];
				if (!isBuiltin(identifier) && args.length > 1) {
					throw new MathParseError("Unrecognized function: "~identifier);
				}
				return;
			}
		}
		throw new MathParseError("Unexpected end of input: "~source);
	}
	/// Return the simplification of this node (where possible).
	IMathObject simplify(real[string]vars) {
		mixin(tryEval);
		if (isBuiltin(identifier)) {
			// a function!
			// attempt evaluation of subnodes
			foreach (ref arg;args) {
				arg = arg.simplify(vars);
			}
			return this;
		} else {
			// a variable?
			if (args.length) {
				// try to simplify the arg/mul
				args[0] = args[0].simplify(vars);
			}
			if (identifier in vars) {
				// since we can resolve the identifier, do so
				auto num = new MONumber(vars[identifier]);
				if (!args.length) return num;
				// convert into a multiplication
				auto op = new MOOperation(MOOpType.Multiplication, [cast(IMathObject)num, new MOParens(args[0])]);
				// this needs parens to ensure proper display when required
				// and proper reparsing upon output
				return op.simplify(vars);
			}
			return this;
		}
	}
}

class MOOperation:IMathObject {
	IMathObject[]operands;
	MOOpType op;
	/// Constructor that takes pre-parsed objects and an op
	this (MOOpType inop, IMathObject[]ops) {
		op = inop;
		operands = ops;
	}
	/// Empty constructor
	this () {}
	/// Constructor taking an operation
	this (string c) {
		parse(c);
	}
	private bool validate() {
		switch(op) {
		case MOOpType.Addition:
			if (operands.length < 2) throw new MathParseError("Addition requires 2 or more operands");
			break;
		case MOOpType.Multiplication:
			if (operands.length < 2) throw new MathParseError("Multiplication requires 2 or more operands");
			break;
		case MOOpType.Modulus:
			if (operands.length != 2) throw new MathParseError("Modulus requires 2 operands");
			break;
		default: throw new MathParseError("Unknown operation!");
		}
		return true;
	}
	/// Return the string that was used to generate this node.
	override string toString() {
		string[]ret;
		validate();
		foreach (oper;operands) {
			ret ~= oper.toString();
		}
		return ret.join(.toString(op));
	}
	real doAdd(real accum,real add) {
		return accum+add;
	}
	real doMul(real accum,real mul) {
		return accum*mul;
	}
	/// Return the numeric data represented by this node.
	real evaluate(real[string]vars) {
		real delegate(real n1,real n2) doOp;
		validate();
		real accum;
		switch(op) {
		case MOOpType.Addition: 
			doOp = &doAdd;
			accum = 0;
			break;
		case MOOpType.Multiplication:
			doOp = &doMul;
			accum = 1;
			break;
		case MOOpType.Modulus:
			return operands[0].evaluate(vars)%operands[1].evaluate(vars);
		default: throw new MathParseError("Unknown operation!");
		}
		foreach (operand;operands) {
			accum = doOp(accum,operand.evaluate(vars));
		}
		return accum;
	}
	/// This function parses a set of nodes out of an equation string.
	void parse(ref string source) {
		switch (source[0]) {
		case '+': op = MOOpType.Addition; break;
		case '*': op = MOOpType.Multiplication; break;
		case '^': op = MOOpType.Exponentiation; break;
		case '%': op = MOOpType.Modulus; break;
		default: throw new MathParseError("Operation not recognized: "~source[0]);
		}
	}
	/// Return the simplification of this node (where possible).
	IMathObject simplify(real[string]vars) {
		mixin(tryEval);
		// simplify operands
		foreach (ref myop;operands) {
			myop = myop.simplify(vars);
		}
		// combine numerics
		real delegate(real n1,real n2) doOp;
		validate();
		real accum,orig;
		switch(op) {
		case MOOpType.Addition: 
			doOp = &doAdd;
			orig = accum = 0;
			break;
		case MOOpType.Multiplication:
			doOp = &doMul;
			orig = accum = 1;
			break;
		case MOOpType.Modulus:
			// no further simplification for modulus
			return this;
		default: throw new MathParseError("Unknown operation!");
		}
		for (int i = 0;i < operands.length;i++) {
			auto tmp = cast(MONumber)operands[i];
			if (tmp) {
				accum = doOp(accum, tmp.evaluate(vars));
				operands[i] = null;
			}
		}
		// fill in the nulls
		for (int i = 0;i < operands.length;i++) {
			if (!operands[i]) {
				operands[i] = operands[$-1];
				operands.length = operands.length - 1;
				i--;
			}
		}
		// additional optimizations for multiplication
		if (op == MOOpType.Multiplication) {
			// if mul by 0
			if (accum == 0) return new MONumber(0);
			// if mul by -1
			if (accum == -1) {
				auto neg = new MONegation();
				auto par = new MOParens(this);
				// wrap this in a MONegation and return it
				if (operands.length == 1) par.holder = operands[0];
				neg.rhs = par;
				return neg;
			}
		}
		// identity operation simplification for both addition and multiplication
		if (orig != accum) {
			operands ~= new MONumber(accum);
		}
		// if we've optimized out all but one parameter, this operation is irrelevant
		if (operands.length == 1) return operands[0];
		return this;
	}
	void flatten() {
		// flatten everything we can
		for (int i = 0;i < operands.length;i++) {
			auto tmp = cast(MOOperation)operands[i];
			if (tmp) {
				if (tmp.op == op) {
					operands ~= tmp.operands;
					operands[i] = null;
				} else {
					tmp.flatten();
				}
			}
		}
		// fill in the nulls
		for (int i = 0;i < operands.length;i++) {
			if (!operands[i]) {
				operands[i] = operands[$-1];
				operands.length = operands.length - 1;
				i--;
			}
		}
	}
}

class MOParens:IMathObject {
	IMathObject holder;
	/// Constructor that takes a pre-parsed object
	this(IMathObject obj) {
		holder = obj;
	}
	/// Constructor that eats an input string
	this(ref string input) {
		parse(input);
	}
	/// Return the string that was used to generate this node.
	override string toString() {
		return "("~holder.toString()~")";
	}
	/// Return the numeric data represented by this node.
	real evaluate(real[string]vars) {
		return holder.evaluate(vars);
	}
	/// This function parses a set of nodes out of an equation string.
	void parse(ref string input) {
		// find the end of the paren that opens here
		if (!input.length || input[0] != '(') {
			throw new MathParseError("Couldn't instantiate parens");
		}
		int count = 0;
		foreach (i,c;input) {
			switch (c) {
			case '(': count++; break;
			case ')': count--; break;
			default: break;
			}
			if (!count) {
				holder = parseMathExpr(input[1..i]);
				// skip the closing paren
				input = input[i+1..$];
				return;
			}
		}
		throw new MathParseError("Unexpected end of input: "~input);
	}
	/// Return the simplification of this node (where possible).
	IMathObject simplify(real[string]vars) {
		mixin(tryEval);
		// it only makes sense to pass the simplification up the tree here, parens perform no real ops
		holder = holder.simplify(vars);
		return this;
	}
}

class MONumber:IMathObject {
	real _data;
	/// Empty constructor
	this () {}
	/// Real constructor
	this (real indata) {_data = indata;}
	/// Constructor that eats an input string
	this (ref string input) {
		parse(input);
	}
	/// Return the string that was used to generate this node.
	override string toString() {
		return tostring(_data);
	}
	/// Return the numeric data represented by this node.
	real evaluate(real[string]vars) {
		return _data;
	}
	/// This function parses a number out of a string and eats characters as it goes, hence the ref string parameter.
	void parse(ref string source) {
		// this parser sucks...
		int i = 0;
		// sift through whole numerics
		if (i < source.length && source[i] <= '9' && source[i] >= '0') {
			while (i < source.length && source[i] >= '0' && source[i] <= '9') i++;
		} else if (i < source.length && source[i] != '.') throw new MathParseError("A numeric parse error occurred while parsing the numeric beginning at: "~source);
		// if the next char is not a '.', we know we're done with fractional parts 
		if (i < source.length) {
			if (source[i] == '.') {
				i++;
				while (i < source.length && source[i] >= '0' && source[i] <= '9') i++;
			}
			// if the next char is e or E, we're poking at an exponential
			if (i < source.length && (source[i] == 'e' || source[i] == 'E')) {
				i++;
				if (source[i] == '-' || source[i] == '+') i++;
				while (i< source.length && source[i] >= '0' && source[i] <= '9') i++;
			}
		}
		_data = atof(source[0..i]);
		source = stripl(source[i..$]);
	}
	/// Return the simplification of this node (where possible).
	IMathObject simplify(real[string]vars) {
		// this is already as simpified as it gets
		return this;
	}
}

version(MATHEXPR_main) {
void main() {}
}

unittest {
	real[string]vars;
	void tryGood(string expr,real expected) {
		logln("MathExpr: "~expr~" == "~tostring(expected)~"\n");
		assert(parseMathExpr(expr).evaluate(vars) == expected);
	}
	void tryBad(string expr) {
		logln("MathExpr: "~expr~" (intentional bad expression)\n");
		try {
			parseMathExpr(expr).evaluate(vars);
			assert(0);
		} catch {}
	}
	void setVar(string var,real val) {
		vars[var] = val;
		logln("Set "~var~" to "~tostring(val)~"\n");
	}
	setVar("x",3);
	tryGood("x+x",6);
	tryGood("2x",6);
	tryGood("x+4",7);
	tryGood("12/4",3);
	tryGood("x^x",27);
	tryGood("-1",-1);
	tryGood("-x",-3);
	tryGood("2*-x",-6);
	tryGood("-x*2",-6);
	tryGood("-x^2",-9);
	tryGood("2^-x",0.125);
	tryGood("2^----x",8);
	tryGood("2x",6);
	tryGood("cos(x)",cos(3));
	tryGood("5cos(x)",5*cos(3));
	tryGood("3x+2",11);
	tryGood("(46+36+52+41+27+56+30+24+30)/9",38);
	tryGood("1(-0)",0);
	tryGood("0/1",0);
	logln("MathExpr: cos(3x+2)\n");
	real t1 = parseMathExpr("cos(3x+2)").evaluate(vars),t2 = cos(11);
	logln("got "~tostring(t1)~" == "~tostring(t2)~"\n");
	//assert(feqrel(t1,t2));
	setVar("y",32);
	tryGood("x+y",vars["x"]+vars["y"]);
	setVar("toaster",5);
	tryGood("x(4)toaster",vars["x"]*4*vars["toaster"]);
	tryGood("4*3/3",4);
	tryGood("x3x",27);
	tryGood("04 / 02",2);
	tryGood("int(4.5)",4);
	tryGood("frac(4.5)",0.5);
	tryGood("mod(4.5,1)",0.5);
	tryGood("4.5*1",4.5);
	tryGood("4.5%1",0.5);
	tryGood("5*4.5%3*3+1",5.5);
	tryBad("blah(4)");
	tryBad("3++3");// should probably evaluate good...
	tryBad("3//3");
	tryBad("3**3");
	tryBad("3^^3");
	tryBad("3+-*3");
	tryBad("3*/3");
	tryBad("3/*3");
	tryBad("3-/3");
	tryBad("1..4");
	logln("MathExpr: Simplify 3+4\n");
	assert(parseMathExpr("3+4").simplify(vars).toString() == "7");
	logln("MathExpr: Simplify x+z\n");
	assert(parseMathExpr("x+z").simplify(vars).toString() == "z + 3");
	logln("MathExpr: Simplify 7(x+z)\n");
	assert(parseMathExpr("7(x+z)").simplify(vars).toString() == "(z + 3) * 7");
	logln("MathExpr: Simplify 7(x+z-2y)\n");
	assert(parseMathExpr("7(x+z-2y)").simplify(vars).toString() == "(z + -61) * 7");
	logln("Completed all unit tests\n");
}
